/////////////////////////////////////////
// DO NOT MODIFY - This was auto-generated by a tool.

/* The scene class of the status screen. */
declare class Scene_Status extends Scene_MenuBase {
    constructor();
    create();
    initialize();
    onActorChange();
    refreshActor();
    start();
}

/**
 * The Superclass of all scene within the game.
 * 
 * @class Scene_Base
 * @constructor 
 * @extends Stage
*/
declare class Scene_Base extends Stage {
    constructor();

    /**
     * Add the children window to the windowLayer processing.
     * 
     * @method addWindow
     * @instance 
     * @memberof Scene_Base
    */
    addWindow(window);

    /**
     * Attach a reservation to the reserve queue.
     * 
     * @method attachReservation
     * @instance 
     * @memberof Scene_Base
    */
    attachReservation();

    /**
     * Check whether the game should be triggering a gameover.
     * 
     * @method checkGameover
     * @instance 
     * @memberof Scene_Base
    */
    checkGameover();

    /**
     * Create the components and add them to the rendering process.
     * 
     * @method create
     * @instance 
     * @memberof Scene_Base
    */
    create();

    /**
     * Create a Screen sprite for the fadein and fadeOut purpose and
     * add it to the rendering process.
     * 
     * @method createFadeSprite
     * @instance 
     * @memberof Scene_Base
    */
    createFadeSprite(white);

    /**
     * Create the layer for the windows children
     * and add it to the rendering process.
     * 
     * @method createWindowLayer
     * @instance 
     * @memberof Scene_Base
    */
    createWindowLayer();

    /**
     * Remove the reservation from the Reserve queue.
     * 
     * @method detachReservation
     * @instance 
     * @memberof Scene_Base
    */
    detachReservation();

    /**
     * Slowly fade out all the visual and audio of the scene.
     * 
     * @method fadeOutAll
     * @instance 
     * @memberof Scene_Base
    */
    fadeOutAll();

    /**
     * Return the screen fade speed value.
     * 
     * @method fadeSpeed
     * @instance 
     * @memberof Scene_Base
     * @return {Number} Return the fade speed
    */
    fadeSpeed();

    /**
     * Create a instance of Scene_Base.
     * 
     * @instance 
     * @memberof Scene_Base
    */
    initialize();

    /**
     * Returns whether the scene is active or not.
     * 
     * @method isActive
     * @instance 
     * @memberof Scene_Base
     * @return {Boolean} return true if the scene is active
    */
    isActive();

    /**
     * Return whether the scene is busy or not.
     * 
     * @method isBusy
     * @instance
     * @memberof Scene_Base
     * @return {Boolean} Return true if the scene is currently busy
    */
    isBusy();

    /**
     * Return whether the scene is ready to start or not.
     * 
     * @method isReady
     * @instance 
     * @memberof Scene_Base
     * @return {Boolean} Return true if the scene is ready to start
    */
    isReady();

    /**
     * Pop the scene from the stack array and switch to the
     * previous scene.
     * 
     * @method popScene
     * @instance 
     * @memberof Scene_Base
    */
    popScene();

    /**
     * Return a slow screen fade speed value.
     * 
     * @method slowFadeSpeed
     * @instance 
     * @memberof Scene_Base
     * @return {Number} Return the fade speed
    */
    slowFadeSpeed();

    /**
     * Start the scene processing.
     * 
     * @method start
     * @instance 
     * @memberof Scene_Base
    */
    start();

    /**
     * Request a fadeIn screen process.
     * 
     * @method startFadeIn
     * @param {Number} [duration=30] The time the process will take for fadeIn the screen
     * @param {Boolean} [white=false] If true the fadein will be process with a white color else it's will be black
     * 
     * @instance 
     * @memberof Scene_Base
    */
    startFadeIn(duration, white);

    /**
     * Request a fadeOut screen process.
     * 
     * @method startFadeOut
     * @param {Number} [duration=30] The time the process will take for fadeOut the screen
     * @param {Boolean} [white=false] If true the fadeOut will be process with a white color else it's will be black
     * 
     * @instance 
     * @memberof Scene_Base
    */
    startFadeOut(duration, white);

    /**
     * Stop the scene processing.
     * 
     * @method stop
     * @instance 
     * @memberof Scene_Base
    */
    stop();

    /**
     * Terminate the scene before switching to a another scene.
     * 
     * @method terminate
     * @instance 
     * @memberof Scene_Base
    */
    terminate();

    /**
     * Update the scene processing each new frame.
     * 
     * @method update
     * @instance 
     * @memberof Scene_Base
    */
    update();

    /**
     * Update the children of the scene EACH frame.
     * 
     * @method updateChildren
     * @instance 
     * @memberof Scene_Base
    */
    updateChildren();

    /**
     * Update the screen fade processing.
     * 
     * @method updateFade
     * @instance 
     * @memberof Scene_Base
    */
    updateFade();
}

/* The scene class of the title screen. */
declare class Scene_Title extends Scene_Base {
    constructor();
    centerSprite(sprite);
    commandContinue();
    commandNewGame();
    commandOptions();
    create();
    createBackground();
    createCommandWindow();
    createForeground();
    drawGameTitle();
    initialize();
    isBusy();
    playTitleMusic();
    start();
    terminate();
    update();
}

/* The scene class of the map screen. */
declare class Scene_Map extends Scene_Base {
    constructor();
    callMenu();
    create();
    createAllWindows();
    createDisplayObjects();
    createMapNameWindow();
    createMessageWindow();
    createScrollTextWindow();
    createSpriteset();
    encounterEffectSpeed();
    fadeInForTransfer();
    fadeOutForTransfer();
    initialize();
    isBusy();
    isDebugCalled();
    isFastForward();
    isMapTouchOk();
    isMenuCalled();
    isMenuEnabled();
    isReady();
    isSceneChangeOk();
    launchBattle();
    needsFadeIn();
    needsSlowFadeOut();
    onMapLoaded();
    processMapTouch();
    snapForBattleBackground();
    start();
    startEncounterEffect();
    startFlashForEncounter(duration);
    stop();
    stopAudioOnBattleStart();
    terminate();
    update();
    updateCallDebug();
    updateCallMenu();
    updateDestination();
    updateEncounter();
    updateEncounterEffect();
    updateMain();
    updateMainMultiply();
    updateScene();
    updateTransferPlayer();
    updateWaitCount();
}

/* The superclass of all the menu-type scenes. */
declare class Scene_MenuBase extends Scene_Base {
    constructor();
    actor();
    create();
    createBackground();
    createHelpWindow();
    initialize();
    nextActor();
    onActorChange();
    previousActor();
    setBackgroundOpacity(opacity);
    updateActor();
}

/* The scene class of the menu screen. */
declare class Scene_Menu extends Scene_MenuBase {
    constructor();
    commandFormation();
    commandGameEnd();
    commandItem();
    commandOptions();
    commandPersonal();
    commandSave();
    create();
    createCommandWindow();
    createGoldWindow();
    createStatusWindow();
    initialize();
    onFormationCancel();
    onFormationOk();
    onPersonalCancel();
    onPersonalOk();
    start();
}

/* The superclass of Scene_Item and Scene_Skill. */
declare class Scene_ItemBase extends Scene_MenuBase {
    constructor();
    activateItemWindow();
    applyItem();
    canUse();
    checkCommonEvent();
    create();
    createActorWindow();
    determineItem();
    hideSubWindow(window);
    initialize();
    isCursorLeft();
    isItemEffectsValid();
    item();
    itemTargetActors();
    onActorCancel();
    onActorOk();
    showSubWindow(window);
    useItem();
    user();
}

/* The scene class of the item screen. */
declare class Scene_Item extends Scene_ItemBase {
    constructor();
    create();
    createCategoryWindow();
    createItemWindow();
    initialize();
    onCategoryOk();
    onItemCancel();
    onItemOk();
    playSeForItem();
    useItem();
    user();
}

/* The scene class of the skill screen. */
declare class Scene_Skill extends Scene_ItemBase {
    constructor();
    commandSkill();
    create();
    createItemWindow();
    createSkillTypeWindow();
    createStatusWindow();
    initialize();
    onActorChange();
    onItemCancel();
    onItemOk();
    playSeForItem();
    refreshActor();
    start();
    useItem();
    user();
}

/* The scene class of the equipment screen. */
declare class Scene_Equip extends Scene_MenuBase {
    constructor();
    commandClear();
    commandEquip();
    commandOptimize();
    create();
    createCommandWindow();
    createItemWindow();
    createSlotWindow();
    createStatusWindow();
    initialize();
    onActorChange();
    onItemCancel();
    onItemOk();
    onSlotCancel();
    onSlotOk();
    refreshActor();
}

/* The scene class for initializing the entire game. */
declare class Scene_Boot extends Scene_Base {
    constructor();
    static loadSystemImages();
    checkPlayerLocation();
    create();
    initialize();
    isGameFontLoaded();
    isReady();
    loadSystemWindowImage();
    start();
    updateDocumentTitle();
}

/* The scene class of the options screen. */
declare class Scene_Options extends Scene_MenuBase {
    constructor();
    create();
    createOptionsWindow();
    initialize();
    terminate();
}

/* The superclass of Scene_Save and Scene_Load. */
declare class Scene_File extends Scene_MenuBase {
    constructor();
    activateListWindow();
    create();
    createHelpWindow();
    createListWindow();
    firstSavefileIndex();
    helpWindowText();
    initialize();
    mode();
    onSavefileOk();
    savefileId();
    start();
}

/* The scene class of the save screen. */
declare class Scene_Save extends Scene_File {
    constructor();
    firstSavefileIndex();
    helpWindowText();
    initialize();
    mode();
    onSaveFailure();
    onSavefileOk();
    onSaveSuccess();
}

/* The scene class of the load screen. */
declare class Scene_Load extends Scene_File {
    constructor();
    firstSavefileIndex();
    helpWindowText();
    initialize();
    mode();
    onLoadFailure();
    onLoadSuccess();
    onSavefileOk();
    reloadMapIfUpdated();
    terminate();
}

/* The scene class of the game end screen. */
declare class Scene_GameEnd extends Scene_MenuBase {
    constructor();
    commandToTitle();
    create();
    createBackground();
    createCommandWindow();
    initialize();
    stop();
}

/* The scene class of the shop screen. */
declare class Scene_Shop extends Scene_MenuBase {
    constructor();
    activateBuyWindow();
    activateSellWindow();
    buyingPrice();
    commandBuy();
    commandSell();
    create();
    createBuyWindow();
    createCategoryWindow();
    createCommandWindow();
    createDummyWindow();
    createGoldWindow();
    createNumberWindow();
    createSellWindow();
    createStatusWindow();
    currencyUnit();
    doBuy(number);
    doSell(number);
    endNumberInput();
    initialize();
    maxBuy();
    maxSell();
    money();
    onBuyCancel();
    onBuyOk();
    onCategoryCancel();
    onCategoryOk();
    onNumberCancel();
    onNumberOk();
    onSellCancel();
    onSellOk();
    prepare(goods, purchaseOnly);
    sellingPrice();
}

/* The scene class of the name input screen. */
declare class Scene_Name extends Scene_MenuBase {
    constructor();
    create();
    createEditWindow();
    createInputWindow();
    initialize();
    onInputOk();
    prepare(actorId, maxLength);
    start();
}

/* The scene class of the debug screen. */
declare class Scene_Debug extends Scene_MenuBase {
    constructor();
    create();
    createDebugHelpWindow();
    createEditWindow();
    createRangeWindow();
    helpText();
    initialize();
    onEditCancel();
    onRangeOk();
    refreshHelpWindow();
}

/* The scene class of the battle screen. */
declare class Scene_Battle extends Scene_Base {
    constructor();
    changeInputWindow();
    commandAttack();
    commandEscape();
    commandFight();
    commandGuard();
    commandItem();
    commandSkill();
    create();
    createActorCommandWindow();
    createActorWindow();
    createAllWindows();
    createDisplayObjects();
    createEnemyWindow();
    createHelpWindow();
    createItemWindow();
    createLogWindow();
    createMessageWindow();
    createPartyCommandWindow();
    createScrollTextWindow();
    createSkillWindow();
    createSpriteset();
    createStatusWindow();
    endCommandSelection();
    initialize();
    isAnyInputWindowActive();
    needsSlowFadeOut();
    onActorCancel();
    onActorOk();
    onEnemyCancel();
    onEnemyOk();
    onItemCancel();
    onItemOk();
    onSelectAction();
    onSkillCancel();
    onSkillOk();
    refreshStatus();
    selectActorSelection();
    selectEnemySelection();
    selectNextCommand();
    selectPreviousCommand();
    start();
    startActorCommandSelection();
    startPartyCommandSelection();
    stop();
    terminate();
    update();
    updateBattleProcess();
    updateStatusWindow();
    updateWindowPositions();
}

/* The scene class of the game over screen. */
declare class Scene_Gameover extends Scene_Base {
    constructor();
    create();
    createBackground();
    gotoTitle();
    initialize();
    isTriggered();
    playGameoverMusic();
    start();
    stop();
    terminate();
    update();
}
