/////////////////////////////////////////
// DO NOT MODIFY - This was auto-generated by a tool.


/**
 * This is not a class, but contains some methods that will be added to the
 * standard Javascript objects.
 *
 * @class JsExtensions
*/
declare function JsExtensions();

/**
 * The tilemap which displays 2D tile-based game map using shaders
 *
 * @class Tilemap
 * @constructor
*/
declare class ShaderTilemap extends Tilemap {
    constructor();

    /**
     * @method _createLayers
     * @private
    */
    _createLayers();

    /**
     * @method _drawAutotile
     * @param {Array} layers
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawAutotile(layer, tileId, dx, dy);

    /**
     * @method _drawNormalTile
     * @param {Array} layers
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawNormalTile(layer, tileId, dx, dy);

    /**
     * @method _drawShadow
     * @param {Number} shadowBits
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawShadow(layer, shadowBits, dx, dy);

    /**
     * @method _drawTableEdge
     * @param {Array} layers
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawTableEdge(layer, tileId, dx, dy);

    /**
     * @method _drawTile
     * @param {Array} layers
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawTile(layer, tileId, dx, dy);

    /**
     * Uploads animation state in renderer
     *
     * @method _hackRenderer
     * @private
    */
    _hackRenderer(renderer);

    /**
     * @method _paintAllTiles
     * @param {Number} startX
     * @param {Number} startY
     * @private
    */
    _paintAllTiles(startX, startY);

    /**
     * @method _paintTiles
     * @param {Number} startX
     * @param {Number} startY
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    _paintTiles(startX, startY, x, y);

    /**
     * @method _updateLayerPositions
     * @param {Number} startX
     * @param {Number} startY
     * @private
    */
    _updateLayerPositions(startX, startY);

    /**
     * Forces to repaint the entire tilemap AND update bitmaps list if needed
     *
     * @method refresh
    */
    refresh();

    /**
     * Call after you update tileset
     *
     * @method updateBitmaps
    */
    refreshTileset();

    /**
     * PIXI render method
     *
     * @method renderCanvas
     * @param {Object} pixi renderer
    */
    renderCanvas(renderer);

    /**
     * PIXI render method
     *
     * @method renderWebGL
     * @param {Object} pixi renderer
    */
    renderWebGL(renderer);

    /**
     * @method updateTransform
     * @private
    */
    updateTransform();
}

declare interface Math {

    /**
     * Generates a random integer in the range (0, max-1).
     *
     * @static
     * @method Math.randomInt
     * @param {Number} max The upper boundary (excluded)
     * @return {Number} A random integer
    */
    randomInt(max);
}

/**
 * The static class that defines utility methods.
 *
 * @class Utils
*/
declare class Utils {
    constructor();
    static _id: number;
    static _supportPassiveEvent;

    /**
     * The name of the RPG Maker. 'MV' in the current version.
     *
     * @static
     * @property RPGMAKER_NAME
     * @type String
     * @final
    */
    static RPGMAKER_NAME: string;

    /**
     * The version of the RPG Maker.
     *
     * @static
     * @property RPGMAKER_VERSION
     * @type String
     * @final
    */
    static RPGMAKER_VERSION: string;

    /**
     * Checks whether the browser can read files in the game folder.
     *
     * @static
     * @method canReadGameFiles
     * @return {Boolean} True if the browser can read files in the game folder
    */
    static canReadGameFiles();
    static generateRuntimeId();

    /**
     * Checks whether the browser is Android Chrome.
     *
     * @static
     * @method isAndroidChrome
     * @return {Boolean} True if the browser is Android Chrome
    */
    static isAndroidChrome();

    /**
     * Checks whether the platform is a mobile device.
     *
     * @static
     * @method isMobileDevice
     * @return {Boolean} True if the platform is a mobile device
    */
    static isMobileDevice();

    /**
     * Checks whether the browser is Mobile Safari.
     *
     * @static
     * @method isMobileSafari
     * @return {Boolean} True if the browser is Mobile Safari
    */
    static isMobileSafari();

    /**
     * Checks whether the platform is NW.js.
     *
     * @static
     * @method isNwjs
     * @return {Boolean} True if the platform is NW.js
    */
    static isNwjs();

    /**
     * Checks whether the option is in the query string.
     *
     * @static
     * @method isOptionValid
     * @param {String} name The option name
     * @return {Boolean} True if the option is in the query string
    */
    static isOptionValid(name);

    /**
     * Test this browser support passive event feature
     * 
     * @static
     * @method isSupportPassiveEvent
     * @return {Boolean} this browser support passive event or not
    */
    static isSupportPassiveEvent();

    /**
     * Makes a CSS color string from RGB values.
     *
     * @static
     * @method rgbToCssColor
     * @param {Number} r The red value in the range (0, 255)
     * @param {Number} g The green value in the range (0, 255)
     * @param {Number} b The blue value in the range (0, 255)
     * @return {String} CSS color string
    */
    static rgbToCssColor(r, g, b);
}

/**
 * The resource class. Allows to be collected as a garbage if not use for some time or ticks
 *
 * @class CacheEntry
 * @constructor
 * @param {ResourceManager} resource manager
 * @param {string} key, url of the resource
 * @param {string} item - Bitmap, HTML5Audio, WebAudio - whatever you want to store in the cache
*/
declare class CacheEntry {
    constructor(cache, key, item);

    /**
     * Allocates the resource
     * @returns {CacheEntry}
    */
    allocate();

    /**
     * frees the resource
    */
    free(byTTL);
    isStillAlive();

    /**
     * Sets the time to live
     * @param {number} ticks TTL in ticks, 0 if not set
     * @param {number} time TTL in seconds, 0 if not set
     * @returns {CacheEntry}
    */
    setTimeToLive(ticks, seconds);

    /**
     * makes sure that resource wont freed by Time To Live
     * if resource was already freed by TTL, put it in cache again
    */
    touch();
}

/**
 * Cache for images, audio, or any other kind of resource
 * @param manager
 * @constructor
*/
declare class CacheMap {
    constructor(manager);

    /**
     * checks ttl of all elements and removes dead ones
    */
    checkTTL();
    clear();

    /**
     * cache item
     * @param key url of cache element
     * @returns {*|null}
    */
    getItem(key);
    setItem(key, item);
    update(ticks, delta);
}

declare class ImageCache {
    constructor();
    static limit: number;
    _mustBeHeld(item);
    _truncateCache();
    add(key, value);
    get(key);
    getErrorBitmap();
    initialize();
    isReady();
    releaseReservation(reservationId);
    reserve(key, value, reservationId);
}

declare class RequestQueue {
    constructor();
    clear();
    enqueue(key, value);
    initialize();
    raisePriority(key);
    update();
}

/**
 * The point class.
 *
 * @class Point
 * @constructor
 * @param {Number} x The x coordinate
 * @param {Number} y The y coordinate
*/
declare class Point extends PIXI.Point {
    constructor(x, y);
    initialize(x?, y?);
}

/**
 * The rectangle class.
 *
 * @class Rectangle
 * @constructor
 * @param {Number} x The x coordinate for the upper-left corner
 * @param {Number} y The y coordinate for the upper-left corner
 * @param {Number} width The width of the rectangle
 * @param {Number} height The height of the rectangle
*/
declare class Rectangle extends PIXI.Rectangle {
    constructor(x, y, width, height);

    /**
     * @static
     * @property emptyRectangle
     * @type Rectangle
     * @private
    */
    static emptyRectangle: Rectangle;
    initialize(x?, y?, width?, height?);
}

/**
 * The basic object that represents an image.
 *
 * @class Bitmap
 * @constructor
 * @param {Number} width The width of the bitmap
 * @param {Number} height The height of the bitmap
*/
declare class Bitmap {
    constructor(width, height);

    /* for iOS. img consumes memory. so reuse it. */
    static _reuseImages: any[];
    _baseTexture;
    _canvas;
    _context;
    baseTexture;
    canvas;
    context;
    height;
    paintOpacity;
    rect;
    smooth;
    url;
    width;

    /**
     * Loads a image file and returns a new bitmap object.
     *
     * @static
     * @method load
     * @param {String} url The image url of the texture
     * @return Bitmap
    */
    static load(url);
    static request(url);

    /**
     * Takes a snapshot of the game screen and returns a new bitmap object.
     *
     * @static
     * @method snap
     * @param {Stage} stage The stage object
     * @return Bitmap
    */
    static snap(stage);

    /**
     * @method _callLoadListeners
     * @private
    */
    _callLoadListeners();
    _clearImgInstance();
    _createBaseTexture(source);
    _createCanvas(width, height);

    /**
     * @method _drawTextBody
     * @param {String} text
     * @param {Number} tx
     * @param {Number} ty
     * @param {Number} maxWidth
     * @private
    */
    _drawTextBody(text, tx, ty, maxWidth);

    /**
     * @method _drawTextOutline
     * @param {String} text
     * @param {Number} tx
     * @param {Number} ty
     * @param {Number} maxWidth
     * @private
    */
    _drawTextOutline(text, tx, ty, maxWidth);

    /**
     * @method _makeFontNameText
     * @private
    */
    _makeFontNameText();

    /**
     * @method _onError
     * @private
    */
    _onError();

    /**
     * @method _onLoad
     * @private
    */
    _onLoad();
    _renewCanvas();
    _requestImage(url);

    /**
     * @method _setDirty
     * @private
    */
    _setDirty();

    /**
     * Add a callback function that will be called when the bitmap is loaded.
     *
     * @method addLoadListener
     * @param {Function} listner The callback function
    */
    addLoadListener(listner);

    /**
     * Changes the color tone of the entire bitmap.
     *
     * @method adjustTone
     * @param {Number} r The red strength in the range (-255, 255)
     * @param {Number} g The green strength in the range (-255, 255)
     * @param {Number} b The blue strength in the range (-255, 255)
    */
    adjustTone(r, g, b);

    /**
     * Performs a block transfer.
     *
     * @method blt
     * @param {Bitmap} source The bitmap to draw
     * @param {Number} sx The x coordinate in the source
     * @param {Number} sy The y coordinate in the source
     * @param {Number} sw The width of the source image
     * @param {Number} sh The height of the source image
     * @param {Number} dx The x coordinate in the destination
     * @param {Number} dy The y coordinate in the destination
     * @param {Number} [dw=sw] The width to draw the image in the destination
     * @param {Number} [dh=sh] The height to draw the image in the destination
    */
    blt(source, sx, sy, sw, sh, dx, dy, dw, dh);

    /**
     * Performs a block transfer, using assumption that original image was not modified (no hue)
     *
     * @method blt
     * @param {Bitmap} source The bitmap to draw
     * @param {Number} sx The x coordinate in the source
     * @param {Number} sy The y coordinate in the source
     * @param {Number} sw The width of the source image
     * @param {Number} sh The height of the source image
     * @param {Number} dx The x coordinate in the destination
     * @param {Number} dy The y coordinate in the destination
     * @param {Number} [dw=sw] The width to draw the image in the destination
     * @param {Number} [dh=sh] The height to draw the image in the destination
    */
    bltImage(source, sx, sy, sw, sh, dx, dy, dw, dh);

    /**
     * Applies a blur effect to the bitmap.
     *
     * @method blur
    */
    blur();

    /**
     * updates texture is bitmap was dirty
     * @method checkDirty
    */
    checkDirty();

    /**
     * Clears the entire bitmap.
     *
     * @method clear
    */
    clear();

    /**
     * Clears the specified rectangle.
     *
     * @method clearRect
     * @param {Number} x The x coordinate for the upper-left corner
     * @param {Number} y The y coordinate for the upper-left corner
     * @param {Number} width The width of the rectangle to clear
     * @param {Number} height The height of the rectangle to clear
    */
    clearRect(x, y, width, height);
    decode();

    /**
     * Draw a bitmap in the shape of a circle
     *
     * @method drawCircle
     * @param {Number} x The x coordinate based on the circle center
     * @param {Number} y The y coordinate based on the circle center
     * @param {Number} radius The radius of the circle
     * @param {String} color The color of the circle in CSS format
    */
    drawCircle(x, y, radius, color);

    /**
     * Draws the outline text to the bitmap.
     *
     * @method drawText
     * @param {String} text The text that will be drawn
     * @param {Number} x The x coordinate for the left of the text
     * @param {Number} y The y coordinate for the top of the text
     * @param {Number} maxWidth The maximum allowed width of the text
     * @param {Number} lineHeight The height of the text line
     * @param {String} align The alignment of the text
    */
    drawText(text, x, y, maxWidth, lineHeight, align);

    /**
     * Fills the entire bitmap.
     *
     * @method fillAll
     * @param {String} color The color of the rectangle in CSS format
    */
    fillAll(color);

    /**
     * Fills the specified rectangle.
     *
     * @method fillRect
     * @param {Number} x The x coordinate for the upper-left corner
     * @param {Number} y The y coordinate for the upper-left corner
     * @param {Number} width The width of the rectangle to fill
     * @param {Number} height The height of the rectangle to fill
     * @param {String} color The color of the rectangle in CSS format
    */
    fillRect(x, y, width, height, color);

    /**
     * Returns alpha pixel value at the specified point.
     *
     * @method getAlphaPixel
     * @param {Number} x The x coordinate of the pixel in the bitmap
     * @param {Number} y The y coordinate of the pixel in the bitmap
     * @return {String} The alpha value
    */
    getAlphaPixel(x, y);

    /**
     * Returns pixel color at the specified point.
     *
     * @method getPixel
     * @param {Number} x The x coordinate of the pixel in the bitmap
     * @param {Number} y The y coordinate of the pixel in the bitmap
     * @return {String} The pixel color (hex format)
    */
    getPixel(x, y);

    /**
     * Draws the rectangle with a gradation.
     *
     * @method gradientFillRect
     * @param {Number} x The x coordinate for the upper-left corner
     * @param {Number} y The y coordinate for the upper-left corner
     * @param {Number} width The width of the rectangle to fill
     * @param {Number} height The height of the rectangle to fill
     * @param {String} color1 The gradient starting color
     * @param {String} color2 The gradient ending color
     * @param {Boolean} vertical Wether the gradient should be draw as vertical or not
    */
    gradientFillRect(x, y, width, height, color1, color2, vertical);
    initialize(width?, height?);

    /**
     * Checks whether a loading error has occurred.
     *
     * @method isError
     * @return {Boolean} True if a loading error has occurred
    */
    isError();

    /**
     * Checks whether the bitmap is ready to render.
     *
     * @method isReady
     * @return {Boolean} True if the bitmap is ready to render
    */
    isReady();
    isRequestOnly();
    isRequestReady();

    /**
     * Returns the width of the specified text.
     *
     * @method measureTextWidth
     * @param {String} text The text to be measured
     * @return {Number} The width of the text in pixels
    */
    measureTextWidth(text);

    /**
     * Resizes the bitmap.
     *
     * @method resize
     * @param {Number} width The new width of the bitmap
     * @param {Number} height The new height of the bitmap
    */
    resize(width, height);

    /**
     * Rotates the hue of the entire bitmap.
     *
     * @method rotateHue
     * @param {Number} offset The hue offset in 360 degrees
    */
    rotateHue(offset);
    startRequest();

    /**
     * touch the resource
     * @method touch
    */
    touch();
}

/**
 * The static class that carries out graphics processing.
 *
 * @class Graphics
*/
declare class Graphics {
    constructor(width, height, type);
    static _fontLoaded;
    static _videoVolume: number;

    /**
     * The alias of PIXI.blendModes.ADD.
     *
     * @static
     * @property BLEND_ADD
     * @type Number
     * @final
    */
    static BLEND_ADD: number;

    /**
     * The alias of PIXI.blendModes.MULTIPLY.
     *
     * @static
     * @property BLEND_MULTIPLY
     * @type Number
     * @final
    */
    static BLEND_MULTIPLY: number;

    /**
     * The alias of PIXI.blendModes.NORMAL.
     *
     * @static
     * @property BLEND_NORMAL
     * @type Number
     * @final
    */
    static BLEND_NORMAL: number;

    /**
     * The alias of PIXI.blendModes.SCREEN.
     *
     * @static
     * @property BLEND_SCREEN
     * @type Number
     * @final
    */
    static BLEND_SCREEN: number;
    static boxHeight;
    static boxWidth;

    /**
     * The total frame count of the game screen.
     *
     * @static
     * @property frameCount
     * @type Number
    */
    static frameCount: number;
    static height;
    static scale;
    static width;

    /**
     * @static
     * @method _applyCanvasFilter
     * @private
    */
    static _applyCanvasFilter();

    /**
     * @static
     * @method _cancelFullScreen
     * @private
    */
    static _cancelFullScreen();

    /**
     * @static
     * @method _centerElement
     * @param {HTMLElement} element
     * @private
    */
    static _centerElement(element);

    /**
     * @static
     * @method _clearUpperCanvas
     * @private
    */
    static _clearUpperCanvas();

    /**
     * @static
     * @method _createAllElements
     * @private
    */
    static _createAllElements();

    /**
     * @static
     * @method _createCanvas
     * @private
    */
    static _createCanvas();

    /**
     * @static
     * @method _createErrorPrinter
     * @private
    */
    static _createErrorPrinter();

    /**
     * @static
     * @method _createFontLoader
     * @param {String} name
     * @private
    */
    static _createFontLoader(name);

    /**
     * @static
     * @method _createFPSMeter
     * @private
    */
    static _createFPSMeter();

    /**
     * @static
     * @method _createGameFontLoader
     * @private
    */
    static _createGameFontLoader();

    /**
     * @static
     * @method _createModeBox
     * @private
    */
    static _createModeBox();

    /**
     * @static
     * @method _createRenderer
     * @private
    */
    static _createRenderer();

    /**
     * @static
     * @method _createUpperCanvas
     * @private
    */
    static _createUpperCanvas();

    /**
     * @static
     * @method _createVideo
     * @private
    */
    static _createVideo();

    /**
     * @static
     * @method _defaultStretchMode
     * @private
    */
    static _defaultStretchMode();

    /**
     * @static
     * @method _disableContextMenu
     * @private
    */
    static _disableContextMenu();

    /**
     * @static
     * @method _disableTextSelection
     * @private
    */
    static _disableTextSelection();

    /**
     * @static
     * @method _isFullScreen
     * @return {Boolean}
     * @private
    */
    static _isFullScreen();

    /**
     * @static
     * @method _isVideoVisible
     * @return {Boolean}
     * @private
    */
    static _isVideoVisible();

    /**
     * @static
     * @method _makeErrorHtml
     * @param {String} name
     * @param {String} message
     * @return {String}
     * @private
    */
    static _makeErrorHtml(name, message);

    /**
     * @static
     * @method _modifyExistingElements
     * @private
    */
    static _modifyExistingElements();

    /**
     * @static
     * @method _onKeyDown
     * @param {KeyboardEvent} event
     * @private
    */
    static _onKeyDown(event);

    /**
     * @static
     * @method _onTouchEnd
     * @param {TouchEvent} event
     * @private
    */
    static _onTouchEnd(event);

    /**
     * @static
     * @method _onVideoEnd
     * @private
    */
    static _onVideoEnd();

    /**
     * @static
     * @method _onVideoError
     * @private
    */
    static _onVideoError();

    /**
     * @static
     * @method _onVideoLoad
     * @private
    */
    static _onVideoLoad();

    /**
     * @static
     * @method _onWindowResize
     * @private
    */
    static _onWindowResize();

    /**
     * @static
     * @method _paintUpperCanvas
     * @private
    */
    static _paintUpperCanvas();

    /**
     * @static
     * @method _playVideo
     * @param {String} src
     * @private
    */
    static _playVideo(src);

    /**
     * @static
     * @method _requestFullScreen
     * @private
    */
    static _requestFullScreen();
    static _setupCssFontLoading();

    /**
     * @static
     * @method _setupEventHandlers
     * @private
    */
    static _setupEventHandlers();

    /**
     * @static
     * @method _switchFPSMeter
     * @private
    */
    static _switchFPSMeter();

    /**
     * @static
     * @method _switchFullScreen
     * @private
    */
    static _switchFullScreen();

    /**
     * @static
     * @method _switchStretchMode
     * @return {Boolean}
     * @private
    */
    static _switchStretchMode();

    /**
     * @static
     * @method _testCanvasBlendModes
     * @private
    */
    static _testCanvasBlendModes();

    /**
     * @static
     * @method _updateAllElements
     * @private
    */
    static _updateAllElements();

    /**
     * @static
     * @method _updateCanvas
     * @private
    */
    static _updateCanvas();

    /**
     * @static
     * @method _updateErrorPrinter
     * @private
    */
    static _updateErrorPrinter();

    /**
     * @static
     * @method _updateRealScale
     * @private
    */
    static _updateRealScale();

    /**
     * @static
     * @method _updateRenderer
     * @private
    */
    static _updateRenderer();

    /**
     * @static
     * @method _updateUpperCanvas
     * @private
    */
    static _updateUpperCanvas();

    /**
     * @static
     * @method _updateVideo
     * @private
    */
    static _updateVideo();

    /**
     * @static
     * @method _updateVisibility
     * @param {Boolean} videoVisible
     * @private
    */
    static _updateVisibility(videoVisible);

    /**
     * Calls pixi.js garbage collector
    */
    static callGC();

    /**
     * Checks whether the browser can play the specified video type.
     *
     * @static
     * @method canPlayVideoType
     * @param {String} type The video type to test support for
     * @return {Boolean} True if the browser can play the specified video type
    */
    static canPlayVideoType(type);
    static canUseCssFontLoading();

    /**
     * Checks whether the canvas blend mode 'difference' is supported.
     *
     * @static
     * @method canUseDifferenceBlend
     * @return {Boolean} True if the canvas blend mode 'difference' is supported
    */
    static canUseDifferenceBlend();

    /**
     * Checks whether the canvas blend mode 'saturation' is supported.
     *
     * @static
     * @method canUseSaturationBlend
     * @return {Boolean} True if the canvas blend mode 'saturation' is supported
    */
    static canUseSaturationBlend();

    /**
     * Erases the "Now Loading" image.
     *
     * @static
     * @method endLoading
    */
    static endLoading();

    /**
     * Erases the loading error text.
     *
     * @static
     * @method eraseLoadingError
    */
    static eraseLoadingError();

    /**
     * Checks whether the current browser supports WebGL.
     *
     * @static
     * @method hasWebGL
     * @return {Boolean} True if the current browser supports WebGL.
    */
    static hasWebGL();

    /**
     * Hides the FPSMeter element.
     *
     * @static
     * @method hideFps
    */
    static hideFps();

    /**
     * Initializes the graphics system.
     *
     * @static
     * @method initialize
     * @param {Number} width The width of the game screen
     * @param {Number} height The height of the game screen
     * @param {String} type The type of the renderer.
     *                 'canvas', 'webgl', or 'auto'.
    */
    static initialize(width?, height?, type?);

    /**
     * Checks whether the font file is loaded.
     *
     * @static
     * @method isFontLoaded
     * @param {String} name The face name of the font
     * @return {Boolean} True if the font file is loaded
    */
    static isFontLoaded(name);

    /**
     * Checks whether the specified point is inside the game canvas area.
     *
     * @static
     * @method isInsideCanvas
     * @param {Number} x The x coordinate on the canvas area
     * @param {Number} y The y coordinate on the canvas area
     * @return {Boolean} True if the specified point is inside the game canvas area
    */
    static isInsideCanvas(x, y);

    /**
     * Checks whether the video is playing.
     *
     * @static
     * @method isVideoPlaying
     * @return {Boolean} True if the video is playing
    */
    static isVideoPlaying();

    /**
     * Checks whether the renderer type is WebGL.
     *
     * @static
     * @method isWebGL
     * @return {Boolean} True if the renderer type is WebGL
    */
    static isWebGL();

    /**
     * Loads a font file.
     *
     * @static
     * @method loadFont
     * @param {String} name The face name of the font
     * @param {String} url The url of the font file
    */
    static loadFont(name, url);

    /**
     * Converts an x coordinate on the page to the corresponding
     * x coordinate on the canvas area.
     *
     * @static
     * @method pageToCanvasX
     * @param {Number} x The x coordinate on the page to be converted
     * @return {Number} The x coordinate on the canvas area
    */
    static pageToCanvasX(x);

    /**
     * Converts a y coordinate on the page to the corresponding
     * y coordinate on the canvas area.
     *
     * @static
     * @method pageToCanvasY
     * @param {Number} y The y coordinate on the page to be converted
     * @return {Number} The y coordinate on the canvas area
    */
    static pageToCanvasY(y);

    /**
     * Starts playback of a video.
     *
     * @static
     * @method playVideo
     * @param {String} src
    */
    static playVideo(src);

    /**
     * Displays the error text to the screen.
     *
     * @static
     * @method printError
     * @param {String} name The name of the error
     * @param {String} message The message of the error
    */
    static printError(name, message);

    /**
     * Displays the loading error text to the screen.
     *
     * @static
     * @method printLoadingError
     * @param {String} url The url of the resource failed to load
    */
    static printLoadingError(url);

    /**
     * Renders the stage to the game screen.
     *
     * @static
     * @method render
     * @param {Stage} stage The stage object to be rendered
    */
    static render(stage);

    /**
     * Sets the source of the "Now Loading" image.
     *
     * @static
     * @method setLoadingImage
    */
    static setLoadingImage(src);

    /**
     * Sets volume of a video.
     *
     * @static
     * @method setVideoVolume
     * @param {Number} value
    */
    static setVideoVolume(value);

    /**
     * Shows the FPSMeter element.
     *
     * @static
     * @method showFps
    */
    static showFps();

    /**
     * Initializes the counter for displaying the "Now Loading" image.
     *
     * @static
     * @method startLoading
    */
    static startLoading();

    /**
     * Marks the end of each frame for FPSMeter.
     *
     * @static
     * @method tickEnd
    */
    static tickEnd();

    /**
     * Marks the beginning of each frame for FPSMeter.
     *
     * @static
     * @method tickStart
    */
    static tickStart();

    /**
     * Increments the loading counter and displays the "Now Loading" image if necessary.
     *
     * @static
     * @method updateLoading
    */
    static updateLoading();
}

/**
 * The static class that handles input data from the keyboard and gamepads.
 *
 * @class Input
*/
declare class Input {
    constructor();
    static date;
    static dir4;
    static dir8;

    /**
     * A hash table to convert from a gamepad button to a mapped key name.
     *
     * @static
     * @property gamepadMapper
     * @type Object
    */
    static gamepadMapper: number;

    /**
     * A hash table to convert from a virtual key code to a mapped key name.
     *
     * @static
     * @property keyMapper
     * @type Object
    */
    static keyMapper: number;

    /**
     * The interval of the key repeat in frames.
     *
     * @static
     * @property keyRepeatInterval
     * @type Number
    */
    static keyRepeatInterval: number;

    /**
     * The wait time of the key repeat in frames.
     *
     * @static
     * @property keyRepeatWait
     * @type Number
    */
    static keyRepeatWait: number;

    /**
     * @static
     * @method _isEscapeCompatible
     * @param {String} keyName
     * @return {Boolean}
     * @private
    */
    static _isEscapeCompatible(keyName);

    /**
     * @static
     * @method _makeNumpadDirection
     * @param {Number} x
     * @param {Number} y
     * @return {Number}
     * @private
    */
    static _makeNumpadDirection(x, y);

    /**
     * @static
     * @method _onKeyDown
     * @param {KeyboardEvent} event
     * @private
    */
    static _onKeyDown(event);

    /**
     * @static
     * @method _onKeyUp
     * @param {KeyboardEvent} event
     * @private
    */
    static _onKeyUp(event);

    /**
     * @static
     * @method _onLostFocus
     * @private
    */
    static _onLostFocus();

    /**
     * @static
     * @method _pollGamepads
     * @private
    */
    static _pollGamepads();

    /**
     * @static
     * @method _setupEventHandlers
     * @private
    */
    static _setupEventHandlers();

    /**
     * @static
     * @method _shouldPreventDefault
     * @param {Number} keyCode
     * @private
    */
    static _shouldPreventDefault(keyCode);

    /**
     * @static
     * @method _signX
     * @private
    */
    static _signX();

    /**
     * @static
     * @method _signY
     * @private
    */
    static _signY();

    /**
     * @static
     * @method _updateDirection
     * @private
    */
    static _updateDirection();

    /**
     * @static
     * @method _updateGamepadState
     * @param {Gamepad} gamepad
     * @param {Number} index
     * @private
    */
    static _updateGamepadState(gamepad);

    /**
     * @static
     * @method _wrapNwjsAlert
     * @private
    */
    static _wrapNwjsAlert();

    /**
     * Clears all the input data.
     *
     * @static
     * @method clear
    */
    static clear();

    /**
     * Initializes the input system.
     *
     * @static
     * @method initialize
    */
    static initialize();

    /**
     * Checks whether a key is kept depressed.
     *
     * @static
     * @method isLongPressed
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is long-pressed
    */
    static isLongPressed(keyName);

    /**
     * Checks whether a key is currently pressed down.
     *
     * @static
     * @method isPressed
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is pressed
    */
    static isPressed(keyName);

    /**
     * Checks whether a key is just pressed or a key repeat occurred.
     *
     * @static
     * @method isRepeated
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is repeated
    */
    static isRepeated(keyName);

    /**
     * Checks whether a key is just pressed.
     *
     * @static
     * @method isTriggered
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is triggered
    */
    static isTriggered(keyName);

    /**
     * Updates the input data.
     *
     * @static
     * @method update
    */
    static update();
}

/**
 * The static class that handles input data from the mouse and touchscreen.
 *
 * @class TouchInput
*/
declare class TouchInput {
    constructor();
    static date;

    /**
     * The interval of the pseudo key repeat in frames.
     *
     * @static
     * @property keyRepeatInterval
     * @type Number
    */
    static keyRepeatInterval: number;

    /**
     * The wait time of the pseudo key repeat in frames.
     *
     * @static
     * @property keyRepeatWait
     * @type Number
    */
    static keyRepeatWait: number;
    static wheelX;
    static wheelY;
    static x;
    static y;

    /**
     * @static
     * @method _onCancel
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    static _onCancel(x, y);

    /**
     * @static
     * @method _onLeftButtonDown
     * @param {MouseEvent} event
     * @private
    */
    static _onLeftButtonDown(event);

    /**
     * @static
     * @method _onMiddleButtonDown
     * @param {MouseEvent} event
     * @private
    */
    static _onMiddleButtonDown(event);

    /**
     * @static
     * @method _onMouseDown
     * @param {MouseEvent} event
     * @private
    */
    static _onMouseDown(event);

    /**
     * @static
     * @method _onMouseMove
     * @param {MouseEvent} event
     * @private
    */
    static _onMouseMove(event);

    /**
     * @static
     * @method _onMouseUp
     * @param {MouseEvent} event
     * @private
    */
    static _onMouseUp(event);

    /**
     * @static
     * @method _onMove
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    static _onMove(x, y);

    /**
     * @static
     * @method _onPointerDown
     * @param {PointerEvent} event
     * @private
    */
    static _onPointerDown(event);

    /**
     * @static
     * @method _onRelease
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    static _onRelease(x, y);

    /**
     * @static
     * @method _onRightButtonDown
     * @param {MouseEvent} event
     * @private
    */
    static _onRightButtonDown(event);

    /**
     * @static
     * @method _onTouchCancel
     * @param {TouchEvent} event
     * @private
    */
    static _onTouchCancel(event);

    /**
     * @static
     * @method _onTouchEnd
     * @param {TouchEvent} event
     * @private
    */
    static _onTouchEnd(event);

    /**
     * @static
     * @method _onTouchMove
     * @param {TouchEvent} event
     * @private
    */
    static _onTouchMove(event);

    /**
     * @static
     * @method _onTouchStart
     * @param {TouchEvent} event
     * @private
    */
    static _onTouchStart(event);

    /**
     * @static
     * @method _onTrigger
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    static _onTrigger(x, y);

    /**
     * @static
     * @method _onWheel
     * @param {WheelEvent} event
     * @private
    */
    static _onWheel(event);

    /**
     * @static
     * @method _setupEventHandlers
     * @private
    */
    static _setupEventHandlers();

    /**
     * Clears all the touch data.
     *
     * @static
     * @method clear
    */
    static clear();

    /**
     * Initializes the touch system.
     *
     * @static
     * @method initialize
    */
    static initialize();

    /**
     * Checks whether the right mouse button is just pressed.
     *
     * @static
     * @method isCancelled
     * @return {Boolean} True if the right mouse button is just pressed
    */
    static isCancelled();

    /**
     * Checks whether the left mouse button or touchscreen is kept depressed.
     *
     * @static
     * @method isLongPressed
     * @return {Boolean} True if the left mouse button or touchscreen is long-pressed
    */
    static isLongPressed();

    /**
     * Checks whether the mouse or a finger on the touchscreen is moved.
     *
     * @static
     * @method isMoved
     * @return {Boolean} True if the mouse or a finger on the touchscreen is moved
    */
    static isMoved();

    /**
     * Checks whether the mouse button or touchscreen is currently pressed down.
     *
     * @static
     * @method isPressed
     * @return {Boolean} True if the mouse button or touchscreen is pressed
    */
    static isPressed();

    /**
     * Checks whether the left mouse button or touchscreen is released.
     *
     * @static
     * @method isReleased
     * @return {Boolean} True if the mouse button or touchscreen is released
    */
    static isReleased();

    /**
     * Checks whether the left mouse button or touchscreen is just pressed
     * or a pseudo key repeat occurred.
     *
     * @static
     * @method isRepeated
     * @return {Boolean} True if the mouse button or touchscreen is repeated
    */
    static isRepeated();

    /**
     * Checks whether the left mouse button or touchscreen is just pressed.
     *
     * @static
     * @method isTriggered
     * @return {Boolean} True if the mouse button or touchscreen is triggered
    */
    static isTriggered();

    /**
     * Updates the touch data.
     *
     * @static
     * @method update
    */
    static update();
}

/**
 * The basic object that is rendered to the game screen.
 *
 * @class Sprite
 * @constructor
 * @param {Bitmap} bitmap The image for the sprite
*/
declare class Sprite extends PIXI.Sprite {
    constructor(bitmap);

    /* Number of the created objects. */
    static _counter: number;
    static VoidFilter;
    bitmap;
    height;
    opacity;
    width;

    /**
     * @method _createTinter
     * @param {Number} w
     * @param {Number} h
     * @private
    */
    _createTinter(w, h);

    /**
     * @method _executeTint
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     * @private
    */
    _executeTint(x, y, w, h);

    /**
     * @method _isInBitmapRect
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     * @return {Boolean}
     * @private
    */
    _isInBitmapRect(x, y, w, h);

    /**
     * @method _needsTint
     * @return {Boolean}
     * @private
    */
    _needsTint();

    /**
     * @method _onBitmapLoad
     * @private
    */
    _onBitmapLoad(bitmapLoaded);

    /**
     * @method _refresh
     * @private
    */
    _refresh();

    /**
     * @method _renderCanvas
     * @param {Object} renderer
     * @private
    */
    _renderCanvas(renderer);

    /**
     * @method _renderWebGL
     * @param {Object} renderer
     * @private
    */
    _renderWebGL(renderer);

    /**
     * checks if we need to speed up custom blendmodes
     * @param renderer
     * @private
    */
    _speedUpCustomBlendModes(renderer);

    /**
     * Gets the blend color for the sprite.
     *
     * @method getBlendColor
     * @return {Array} The blend color [r, g, b, a]
    */
    getBlendColor();

    /**
     * Gets the color tone for the sprite.
     *
     * @method getColorTone
     * @return {Array} The color tone [r, g, b, gray]
    */
    getColorTone();
    initialize(bitmap?);

    /**
     * Sets the x and y at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the sprite
     * @param {Number} y The y coordinate of the sprite
    */
    move(x, y);

    /**
     * Sets the blend color for the sprite.
     *
     * @method setBlendColor
     * @param {Array} color The blend color [r, g, b, a]
    */
    setBlendColor(color);

    /**
     * Sets the color tone for the sprite.
     *
     * @method setColorTone
     * @param {Array} tone The color tone [r, g, b, gray]
    */
    setColorTone(tone);

    /**
     * Sets the rectagle of the bitmap that the sprite displays.
     *
     * @method setFrame
     * @param {Number} x The x coordinate of the frame
     * @param {Number} y The y coordinate of the frame
     * @param {Number} width The width of the frame
     * @param {Number} height The height of the frame
    */
    setFrame(x, y, width, height);

    /**
     * Updates the sprite for each frame.
     *
     * @method update
    */
    update();
}

/**
 * The tilemap which displays 2D tile-based game map.
 *
 * @class Tilemap
 * @constructor
*/
declare class Tilemap extends PIXI.Container {
    constructor();

    /* Autotile shape number to coordinates of tileset images */
    static FLOOR_AUTOTILE_TABLE: number;
    static TILE_ID_A1: number;
    static TILE_ID_A2: number;
    static TILE_ID_A3: number;
    static TILE_ID_A4: number;
    static TILE_ID_A5: number;

    /* Tile type checkers */
    static TILE_ID_B: number;
    static TILE_ID_C: number;
    static TILE_ID_D: number;
    static TILE_ID_E: number;
    static TILE_ID_MAX: number;
    static WALL_AUTOTILE_TABLE: number;
    static WATERFALL_AUTOTILE_TABLE: number;
    height;
    tileHeight;
    tileWidth;
    width;
    static getAutotileKind(tileId);
    static getAutotileShape(tileId);
    static isAutotile(tileId);
    static isFloorTypeAutotile(tileId);
    static isGroundTile(tileId);
    static isRoofTile(tileId);
    static isSameKindTile(tileID1, tileID2);
    static isShadowingTile(tileId);
    static isTileA1(tileId);
    static isTileA2(tileId);
    static isTileA3(tileId);
    static isTileA4(tileId);
    static isTileA5(tileId);
    static isVisibleTile(tileId);
    static isWallSideTile(tileId);
    static isWallTile(tileId);
    static isWallTopTile(tileId);
    static isWallTypeAutotile(tileId);
    static isWaterfallTile(tileId);
    static isWaterfallTypeAutotile(tileId);
    static isWaterTile(tileId);
    static makeAutotileId(kind, shape);

    /**
     * @method _compareChildOrder
     * @param {Object} a
     * @param {Object} b
     * @private
    */
    _compareChildOrder(a, b);

    /**
     * @method _createLayers
     * @private
    */
    _createLayers();

    /**
     * @method _drawAutotile
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawAutotile(bitmap, tileId, dx, dy);

    /**
     * @method _drawNormalTile
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawNormalTile(bitmap, tileId, dx, dy);

    /**
     * @method _drawShadow
     * @param {Bitmap} bitmap
     * @param {Number} shadowBits
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawShadow(bitmap, shadowBits, dx, dy);

    /**
     * @method _drawTableEdge
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawTableEdge(bitmap, tileId, dx, dy);

    /**
     * @method _drawTile
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
    */
    _drawTile(bitmap, tileId, dx, dy);

    /**
     * @method _isHigherTile
     * @param {Number} tileId
     * @return {Boolean}
     * @private
    */
    _isHigherTile(tileId);

    /**
     * @method _isOverpassPosition
     * @param {Number} mx
     * @param {Number} my
     * @return {Boolean}
     * @private
    */
    _isOverpassPosition(mx, my);

    /**
     * @method _isTableTile
     * @param {Number} tileId
     * @return {Boolean}
     * @private
    */
    _isTableTile(tileId);

    /**
     * @method _paintAllTiles
     * @param {Number} startX
     * @param {Number} startY
     * @private
    */
    _paintAllTiles(startX, startY);

    /**
     * @method _paintTiles
     * @param {Number} startX
     * @param {Number} startY
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    _paintTiles(startX, startY, x, y);

    /**
     * @method _readLastTiles
     * @param {Number} i
     * @param {Number} x
     * @param {Number} y
     * @private
    */
    _readLastTiles(i, x, y);

    /**
     * @method _readMapData
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {Number}
     * @private
    */
    _readMapData(x, y, z);

    /**
     * @method _sortChildren
     * @private
    */
    _sortChildren();

    /**
     * @method _updateLayerPositions
     * @param {Number} startX
     * @param {Number} startY
     * @private
    */
    _updateLayerPositions(startX, startY);

    /**
     * @method _writeLastTiles
     * @param {Number} i
     * @param {Number} x
     * @param {Number} y
     * @param {Array} tiles
     * @private
    */
    _writeLastTiles(i, x, y, tiles);
    initialize();

    /**
     * Checks whether the tileset is ready to render.
     *
     * @method isReady
     * @type Boolean
     * @return {Boolean} True if the tilemap is ready
    */
    isReady();

    /**
     * Forces to repaint the entire tilemap.
     *
     * @method refresh
    */
    refresh();

    /**
     * Forces to refresh the tileset
     *
     * @method refresh
    */
    refreshTileset();

    /**
     * Sets the tilemap data.
     *
     * @method setData
     * @param {Number} width The width of the map in number of tiles
     * @param {Number} height The height of the map in number of tiles
     * @param {Array} data The one dimensional array for the map data
    */
    setData(width, height, data);

    /**
     * Updates the tilemap for each frame.
     *
     * @method update
    */
    update();

    /**
     * @method updateTransform
     * @private
    */
    updateTransform();
}

declare interface String {

    /**
     * Checks whether the string contains a given string.
     *
     * @method String.prototype.contains
     * @param {String} string The string to search for
     * @return {Boolean} True if the string contains a given string
    */
    contains(string);

    /**
     * Replaces %1, %2 and so on in the string to the arguments.
     *
     * @method String.prototype.format
     * @param {Any} ...args The objects to format
     * @return {String} A formatted string
    */
    format();

    /**
     * Makes a number string with leading zeros.
     *
     * @method String.prototype.padZero
     * @param {Number} length The length of the output string
     * @return {String} A string with leading zeros
    */
    padZero(length);
}

/**
 * The sprite object for a tiling image.
 *
 * @class TilingSprite
 * @constructor
 * @param {Bitmap} bitmap The image for the tiling sprite
*/
declare class TilingSprite extends PIXI.extras.PictureTilingSprite {
    constructor(bitmap);
    bitmap;
    opacity;

    /**
     * @method _onBitmapLoad
     * @private
    */
    _onBitmapLoad();

    /**
     * @method _refresh
     * @private
    */
    _refresh();

    /**
     * @method _renderCanvas
     * @param {Object} renderer
     * @private
    */
    _renderCanvas(renderer);

    /**
     * @method _renderWebGL
     * @param {Object} renderer
     * @private
    */
    _renderWebGL(renderer);

    /**
     * @method _renderWebGL
     * @param {Object} renderer
     * @private
    */
    _renderWebGL(renderer);
    initialize(bitmap?);

    /**
     * Sets the x, y, width, and height all at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the tiling sprite
     * @param {Number} y The y coordinate of the tiling sprite
     * @param {Number} width The width of the tiling sprite
     * @param {Number} height The height of the tiling sprite
    */
    move(x, y, width, height);

    /**
     * Specifies the region of the image that the tiling sprite will use.
     *
     * @method setFrame
     * @param {Number} x The x coordinate of the frame
     * @param {Number} y The y coordinate of the frame
     * @param {Number} width The width of the frame
     * @param {Number} height The height of the frame
    */
    setFrame(x, y, width, height);

    /**
     * Updates the tiling sprite for each frame.
     *
     * @method update
    */
    update();

    /**
     * @method updateTransform
     * @private
    */
    updateTransform();
}

/**
 * The sprite which covers the entire game screen.
 *
 * @class ScreenSprite
 * @constructor
*/
declare class ScreenSprite extends PIXI.Container {
    constructor();
    static YEPWarned: boolean;
    anchor;
    blendMode;
    opacity;
    static warnYep();
    initialize();

    /**
     * Sets black to the color of the screen sprite.
     *
     * @method setBlack
    */
    setBlack();

    /**
     * Sets the color of the screen sprite by values.
     *
     * @method setColor
     * @param {Number} r The red value in the range (0, 255)
     * @param {Number} g The green value in the range (0, 255)
     * @param {Number} b The blue value in the range (0, 255)
    */
    setColor(r, g, b);

    /**
     * Sets white to the color of the screen sprite.
     *
     * @method setWhite
    */
    setWhite();
}

/**
 * The window in the game.
 *
 * @class Window
 * @constructor
*/
declare interface Window extends PIXI.Container {
    constructor();
    backOpacity;
    contents;
    contentsOpacity;
    height;
    margin;
    opacity;
    openness;
    padding;
    width;
    windowskin;

    /**
     * @method _createAllParts
     * @private
    */
    _createAllParts();

    /**
     * @method _onWindowskinLoad
     * @private
    */
    _onWindowskinLoad();

    /**
     * @method _refreshAllParts
     * @private
    */
    _refreshAllParts();

    /**
     * @method _refreshArrows
     * @private
    */
    _refreshArrows();

    /**
     * @method _refreshBack
     * @private
    */
    _refreshBack();

    /**
     * @method _refreshContents
     * @private
    */
    _refreshContents();

    /**
     * @method _refreshCursor
     * @private
    */
    _refreshCursor();

    /**
     * @method _refreshFrame
     * @private
    */
    _refreshFrame();

    /**
     * @method _refreshPauseSign
     * @private
    */
    _refreshPauseSign();

    /**
     * @method _updateArrows
     * @private
    */
    _updateArrows();

    /**
     * @method _updateContents
     * @private
    */
    _updateContents();

    /**
     * @method _updateCursor
     * @private
    */
    _updateCursor();

    /**
     * @method _updatePauseSign
     * @private
    */
    _updatePauseSign();

    /**
     * Adds a child between the background and contents.
     *
     * @method addChildToBack
     * @param {Object} child The child to add
     * @return {Object} The child that was added
    */
    addChildToBack(child);
    initialize();

    /**
     * Returns true if the window is completely closed (openness == 0).
     *
     * @method isClosed
    */
    isClosed();

    /**
     * Returns true if the window is completely open (openness == 255).
     *
     * @method isOpen
    */
    isOpen();

    /**
     * Sets the x, y, width, and height all at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the window
     * @param {Number} y The y coordinate of the window
     * @param {Number} width The width of the window
     * @param {Number} height The height of the window
    */
    move(x, y, width, height);

    /**
     * Sets the position of the command cursor.
     *
     * @method setCursorRect
     * @param {Number} x The x coordinate of the cursor
     * @param {Number} y The y coordinate of the cursor
     * @param {Number} width The width of the cursor
     * @param {Number} height The height of the cursor
    */
    setCursorRect(x, y, width, height);

    /**
     * Changes the color of the background.
     *
     * @method setTone
     * @param {Number} r The red value in the range (-255, 255)
     * @param {Number} g The green value in the range (-255, 255)
     * @param {Number} b The blue value in the range (-255, 255)
    */
    setTone(r, g, b);

    /**
     * Updates the window for each frame.
     *
     * @method update
    */
    update();

    /**
     * @method updateTransform
     * @private
    */
    updateTransform();
}

/**
 * The layer which contains game windows.
 *
 * @class WindowLayer
 * @constructor
*/
declare class WindowLayer extends PIXI.Container {
    constructor();
    static VoidFilter;
    height;
    width;

    /**
     * @method _canvasClearWindowRect
     * @param {Object} renderSession
     * @param {Window} window
     * @private
    */
    _canvasClearWindowRect(renderSession, window);

    /**
     * @method _maskWindow
     * @param {Window} window
     * @private
    */
    _maskWindow(window, shift);
    initialize();

    /**
     * Sets the x, y, width, and height all at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the window layer
     * @param {Number} y The y coordinate of the window layer
     * @param {Number} width The width of the window layer
     * @param {Number} height The height of the window layer
    */
    move(x, y, width, height);
    onRemoveAsAChild();

    /**
     * @method _renderCanvas
     * @param {Object} renderSession
     * @private
    */
    renderCanvas(renderer);

    /**
     * @method _renderWebGL
     * @param {Object} renderSession
     * @private
    */
    renderWebGL(renderer);

    /**
     * Updates the window layer for each frame.
     *
     * @method update
    */
    update();
}

/**
 * The weather effect which displays rain, storm, or snow.
 *
 * @class Weather
 * @constructor
*/
declare class Weather extends PIXI.Container {
    constructor();

    /**
     * @method _addSprite
     * @private
    */
    _addSprite();

    /**
     * @method _createBitmaps
     * @private
    */
    _createBitmaps();

    /**
     * @method _createDimmer
     * @private
    */
    _createDimmer();

    /**
     * @method _rebornSprite
     * @param {Sprite} sprite
     * @private
    */
    _rebornSprite(sprite);

    /**
     * @method _removeSprite
     * @private
    */
    _removeSprite();

    /**
     * @method _updateAllSprites
     * @private
    */
    _updateAllSprites();

    /**
     * @method _updateDimmer
     * @private
    */
    _updateDimmer();

    /**
     * @method _updateRainSprite
     * @param {Sprite} sprite
     * @private
    */
    _updateRainSprite(sprite);

    /**
     * @method _updateSnowSprite
     * @param {Sprite} sprite
     * @private
    */
    _updateSnowSprite(sprite);

    /**
     * @method _updateSprite
     * @param {Sprite} sprite
     * @private
    */
    _updateSprite(sprite);

    /**
     * @method _updateStormSprite
     * @param {Sprite} sprite
     * @private
    */
    _updateStormSprite(sprite);
    initialize();

    /**
     * Updates the weather for each frame.
     *
     * @method update
    */
    update();
}

/**
 * The color matrix filter for WebGL.
 *
 * @class ToneFilter
 * @extends PIXI.Filter
 * @constructor
*/
declare class ToneFilter extends PIXI.filters.ColorMatrixFilter {
    constructor();

    /**
     * Changes the hue.
     *
     * @method adjustHue
     * @param {Number} value The hue value in the range (-360, 360)
    */
    adjustHue(value);

    /**
     * Changes the saturation.
     *
     * @method adjustSaturation
     * @param {Number} value The saturation value in the range (-255, 255)
    */
    adjustSaturation(value);

    /**
     * Changes the tone.
     *
     * @method adjustTone
     * @param {Number} r The red strength in the range (-255, 255)
     * @param {Number} g The green strength in the range (-255, 255)
     * @param {Number} b The blue strength in the range (-255, 255)
    */
    adjustTone(r, g, b);
}

/**
 * The sprite which changes the screen color in 2D canvas mode.
 *
 * @class ToneSprite
 * @constructor
*/
declare class ToneSprite extends PIXI.Container {
    constructor();

    /**
     * @method _renderCanvas
     * @param {Object} renderSession
     * @private
    */
    _renderCanvas(renderer);

    /**
     * @method _renderWebGL
     * @param {Object} renderSession
     * @private
    */
    _renderWebGL(renderer);

    /**
     * Clears the tone.
     *
     * @method reset
    */
    clear();
    initialize();

    /**
     * Sets the tone.
     *
     * @method setTone
     * @param {Number} r The red strength in the range (-255, 255)
     * @param {Number} g The green strength in the range (-255, 255)
     * @param {Number} b The blue strength in the range (-255, 255)
     * @param {Number} gray The grayscale level in the range (0, 255)
    */
    setTone(r, g, b, gray);
}

/**
 * The root object of the display tree.
 *
 * @class Stage
 * @constructor
*/
declare class Stage extends PIXI.Container {
    constructor();
    initialize();
}

/**
 * The audio object of Web Audio API.
 *
 * @class WebAudio
 * @constructor
 * @param {String} url The url of the audio file
*/
declare class WebAudio {
    constructor(noAudio);
    static _context;
    static _initialized: boolean;
    static _masterGainNode;
    static _masterVolume: number;
    static _unlocked: boolean;
    pan;
    pitch;
    url;
    volume;

    /**
     * @static
     * @method _createContext
     * @private
    */
    static _createContext();

    /**
     * @static
     * @method _createMasterGainNode
     * @private
    */
    static _createMasterGainNode();

    /**
     * @static
     * @method _detectCodecs
     * @private
    */
    static _detectCodecs();

    /**
     * @static
     * @method _fadeIn
     * @param {Number} duration
     * @private
    */
    static _fadeIn(duration);

    /**
     * @static
     * @method _fadeOut
     * @param {Number} duration
     * @private
    */
    static _fadeOut(duration);

    /**
     * @static
     * @method _onHide
     * @private
    */
    static _onHide();

    /**
     * @static
     * @method _onShow
     * @private
    */
    static _onShow();

    /**
     * @static
     * @method _onTouchStart
     * @private
    */
    static _onTouchStart();

    /**
     * @static
     * @method _onVisibilityChange
     * @private
    */
    static _onVisibilityChange();

    /**
     * @static
     * @method _setupEventHandlers
     * @private
    */
    static _setupEventHandlers();

    /**
     * @static
     * @method _shouldMuteOnHide
     * @private
    */
    static _shouldMuteOnHide();

    /**
     * Checks whether the browser can play m4a files.
     *
     * @static
     * @method canPlayM4a
     * @return {Boolean} True if the browser can play m4a files
    */
    static canPlayM4a();

    /**
     * Checks whether the browser can play ogg files.
     *
     * @static
     * @method canPlayOgg
     * @return {Boolean} True if the browser can play ogg files
    */
    static canPlayOgg();

    /**
     * Initializes the audio system.
     *
     * @static
     * @method initialize
     * @param {Boolean} noAudio Flag for the no-audio mode
     * @return {Boolean} True if the audio system is available
    */
    static initialize(noAudio?);

    /**
     * Sets the master volume of the all audio.
     *
     * @static
     * @method setMasterVolume
     * @param {Number} value Master volume (min: 0, max: 1)
    */
    static setMasterVolume(value);

    /**
     * @method _connectNodes
     * @private
    */
    _connectNodes();

    /**
     * @method _createEndTimer
     * @private
    */
    _createEndTimer();

    /**
     * @method _createNodes
     * @private
    */
    _createNodes();

    /**
     * @method _load
     * @param {String} url
     * @private
    */
    _load(url);

    /**
     * @method _onLoad
     * @private
    */
    _onLoad();

    /**
     * @method _onXhrLoad
     * @param {XMLHttpRequest} xhr
     * @private
    */
    _onXhrLoad(xhr);

    /**
     * @method _readBigEndian
     * @param {Uint8Array} array
     * @param {Number} index
     * @private
    */
    _readBigEndian(array, index);

    /**
     * @method _readFourCharacters
     * @param {Uint8Array} array
     * @param {Number} index
     * @private
    */
    _readFourCharacters(array, index);

    /**
     * @method _readLittleEndian
     * @param {Uint8Array} array
     * @param {Number} index
     * @private
    */
    _readLittleEndian(array, index);

    /**
     * @method _readLoopComments
     * @param {Uint8Array} array
     * @private
    */
    _readLoopComments(array);

    /**
     * @method _readMetaData
     * @param {Uint8Array} array
     * @param {Number} index
     * @param {Number} size
     * @private
    */
    _readMetaData(array, index, size);

    /**
     * @method _readMp4
     * @param {Uint8Array} array
     * @private
    */
    _readMp4(array);

    /**
     * @method _readOgg
     * @param {Uint8Array} array
     * @private
    */
    _readOgg(array);

    /**
     * @method _removeEndTimer
     * @private
    */
    _removeEndTimer();

    /**
     * @method _removeNodes
     * @private
    */
    _removeNodes();

    /**
     * @method _startPlaying
     * @param {Boolean} loop
     * @param {Number} offset
     * @private
    */
    _startPlaying(loop, offset);

    /**
     * @method _updatePanner
     * @private
    */
    _updatePanner();

    /**
     * Add a callback function that will be called when the audio data is loaded.
     *
     * @method addLoadListener
     * @param {Function} listner The callback function
    */
    addLoadListener(listner);

    /**
     * Add a callback function that will be called when the playback is stopped.
     *
     * @method addStopListener
     * @param {Function} listner The callback function
    */
    addStopListener(listner);

    /**
     * Clears the audio data.
     *
     * @method clear
    */
    clear();

    /**
     * Performs the audio fade-in.
     *
     * @method fadeIn
     * @param {Number} duration Fade-in time in seconds
    */
    fadeIn(duration);

    /**
     * Performs the audio fade-out.
     *
     * @method fadeOut
     * @param {Number} duration Fade-out time in seconds
    */
    fadeOut(duration);
    initialize(url?);

    /**
     * Checks whether a loading error has occurred.
     *
     * @method isError
     * @return {Boolean} True if a loading error has occurred
    */
    isError();

    /**
     * Checks whether the audio is playing.
     *
     * @method isPlaying
     * @return {Boolean} True if the audio is playing
    */
    isPlaying();

    /**
     * Checks whether the audio data is ready to play.
     *
     * @method isReady
     * @return {Boolean} True if the audio data is ready to play
    */
    isReady();

    /**
     * Plays the audio.
     *
     * @method play
     * @param {Boolean} loop Whether the audio data play in a loop
     * @param {Number} offset The start position to play in seconds
    */
    play(loop, offset);

    /**
     * Gets the seek position of the audio.
     *
     * @method seek
    */
    seek();

    /**
     * Stops the audio.
     *
     * @method stop
    */
    stop();
}

/**
 * The static class that handles HTML5 Audio.
 *
 * @class Html5Audio
 * @constructor
*/
declare class Html5Audio {
    constructor();
    static _audioElement;
    static _gainTweenInterval;
    static _initialized: boolean;
    static _staticSePath;
    static _tweenGain: number;
    static _tweenGainStep: number;
    static _tweenTargetGain: number;
    static _unlocked: boolean;
    static url;
    static volume;

    /**
     * @static
     * @method _applyTweenValue
     * @param {Number} volume
     * @private
    */
    static _applyTweenValue(volume);

    /**
     * @static
     * @method _load
     * @param {String} url
     * @private
    */
    static _load(url);

    /**
     * @static
     * @method _onEnded
     * @private
    */
    static _onEnded();

    /**
     * @static
     * @method _onError
     * @private
    */
    static _onError();

    /**
     * @static
     * @method _onHide
     * @private
    */
    static _onHide();

    /**
     * @static
     * @method _onLoad
     * @private
    */
    static _onLoad();

    /**
     * @static
     * @method _onLoadedData
     * @private
    */
    static _onLoadedData();

    /**
     * @static
     * @method _onShow
     * @private
    */
    static _onShow();

    /**
     * @static
     * @method _onTouchStart
     * @private
    */
    static _onTouchStart();

    /**
     * @static
     * @method _onVisibilityChange
     * @private
    */
    static _onVisibilityChange();

    /**
     * @static
     * @method _setupEventHandlers
     * @private
    */
    static _setupEventHandlers();

    /**
     * @static
     * @method _startGainTween
     * @params {Number} duration
     * @private
    */
    static _startGainTween(duration);

    /**
     * @static
     * @method _startPlaying
     * @param {Boolean} loop
     * @param {Number} offset
     * @private
    */
    static _startPlaying(loop, offset);

    /**
     * Add a callback function that will be called when the audio data is loaded.
     *
     * @static
     * @method addLoadListener
     * @param {Function} listner The callback function
    */
    static addLoadListener(listner);

    /**
     * Clears the audio data.
     *
     * @static
     * @method clear
    */
    static clear();

    /**
     * Performs the audio fade-in.
     *
     * @static
     * @method fadeIn
     * @param {Number} duration Fade-in time in seconds
    */
    static fadeIn(duration);

    /**
     * Performs the audio fade-out.
     *
     * @static
     * @method fadeOut
     * @param {Number} duration Fade-out time in seconds
    */
    static fadeOut(duration);

    /**
     * Initializes the audio system.
     *
     * @static
     * @method initialize
     * @return {Boolean} True if the audio system is available
    */
    static initialize();

    /**
     * Checks whether a loading error has occurred.
     *
     * @static
     * @method isError
     * @return {Boolean} True if a loading error has occurred
    */
    static isError();

    /**
     * Checks whether the audio is playing.
     *
     * @static
     * @method isPlaying
     * @return {Boolean} True if the audio is playing
    */
    static isPlaying();

    /**
     * Checks whether the audio data is ready to play.
     *
     * @static
     * @method isReady
     * @return {Boolean} True if the audio data is ready to play
    */
    static isReady();

    /**
     * Plays the audio.
     *
     * @static
     * @method play
     * @param {Boolean} loop Whether the audio data play in a loop
     * @param {Number} offset The start position to play in seconds
    */
    static play(loop, offset);

    /**
     * Gets the seek position of the audio.
     *
     * @static
     * @method seek
    */
    static seek();

    /**
     * Set the URL of static se.
     *
     * @static
     * @param {String} url
    */
    static setStaticSe(url);

    /**
     * Sets up the Html5 Audio.
     *
     * @static
     * @method setup
     * @param {String} url The url of the audio file
    */
    static setup(url);

    /**
     * Stops the audio.
     *
     * @static
     * @method stop
    */
    static stop();
}

/**
 * The static class that handles JSON with object information.
 *
 * @class JsonEx
*/
declare class JsonEx {
    constructor();
    static _id: number;

    /**
     * The maximum depth of objects.
     *
     * @static
     * @property maxDepth
     * @type Number
     * @default 100
    */
    static maxDepth: number;
    static _cleanMetadata(object);

    /**
     * @static
     * @method _decode
     * @param {Object} value
     * @param {Array} circular
     * @param {Object} registry
     * @return {Object}
     * @private
    */
    static _decode(value, circular, registry);

    /**
     * @static
     * @method _encode
     * @param {Object} value
     * @param {Array} circular
     * @param {Number} depth
     * @return {Object}
     * @private
    */
    static _encode(value, circular, depth);
    static _generateId();

    /**
     * @static
     * @method _getConstructorName
     * @param {Object} value
     * @return {String}
     * @private
    */
    static _getConstructorName(value);
    static _linkCircularReference(contents, circulars, registry);

    /**
     * @static
     * @method _resetPrototype
     * @param {Object} value
     * @param {Object} prototype
     * @return {Object}
     * @private
    */
    static _resetPrototype(value, prototype);
    static _restoreCircularReference(circulars);

    /**
     * Makes a deep copy of the specified object.
     *
     * @static
     * @method makeDeepCopy
     * @param {Object} object The object to be copied
     * @return {Object} The copied object
    */
    static makeDeepCopy(object);

    /**
     * Parses a JSON string and reconstructs the corresponding object.
     *
     * @static
     * @method parse
     * @param {String} json The JSON string
     * @return {Object} The reconstructed object
    */
    static parse(json);

    /**
     * Converts an object to a JSON string with object information.
     *
     * @static
     * @method stringify
     * @param {Object} object The object to be converted
     * @return {String} The JSON string
    */
    static stringify(object);
}

declare class Decrypter {
    constructor();
    static _encryptionKey: string;
    static _headerlength: number;
    static _ignoreList: string;
    static _requestImgFile: any[];
    static _xhrOk: number;
    static hasEncryptedAudio: boolean;
    static hasEncryptedImages: boolean;
    static REMAIN: string;
    static SIGNATURE: string;
    static VER: string;
    static checkImgIgnore(url);
    static createBlobUrl(arrayBuffer);
    static cutArrayHeader(arrayBuffer, length);
    static decryptArrayBuffer(arrayBuffer);
    static decryptHTML5Audio(url, bgm, pos);
    static decryptImg(url, bitmap);
    static extToEncryptExt(url);
    static readEncryptionkey();
}

/**
 * The static class that handles resource loading.
 *
 * @class ResourceHandler
*/
declare class ResourceHandler {
    constructor();
    static _defaultRetryInterval: number;
    static _reloaders: any[];
    static createLoader(url, retryMethod, resignMethod, retryInterval);
    static exists();
    static retry();
}

declare interface Number {

    /**
     * Returns a number whose value is limited to the given range.
     *
     * @method Number.prototype.clamp
     * @param {Number} min The lower boundary
     * @param {Number} max The upper boundary
     * @return {Number} A number in the range (min, max)
    */
    clamp(min, max);

    /**
     * Returns a modulo value which is always positive.
     *
     * @method Number.prototype.mod
     * @param {Number} n The divisor
     * @return {Number} A modulo value
    */
    mod(n);

    /**
     * Makes a number string with leading zeros.
     *
     * @method Number.prototype.padZero
     * @param {Number} length The length of the output string
     * @return {String} A string with leading zeros
    */
    padZero(length);
}

declare class PIXI {
    static DO_CLEAR: boolean;

    /* we need this constant for some platforms (Samsung S4, S5, Tab4, HTC One H8) */
    static FORCE_NATIVE: boolean;
}

declare interface Array<T> {
    clone;
    contains;
    equals;
}
